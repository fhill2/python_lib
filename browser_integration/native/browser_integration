#!/usr/bin/python -u

# FOR DEBUGGING with web-ext
# in ~/dev/app/browser_integration/app
# web-ext run --firefox=nightly --browser-console --verbose --watch-files ../native/browser_integration ../native/browser_integration.json background.js manifest.json
# --browser-console -> nativemessaging stdout shows here
# --firefox -> to open nightly version installed instead
# --watch-files -> so when editing nativemessaging app, the browser also hot reloads
# --verbose -> show logging in terminal that launched firefox <-- this is the only thing that shows nativemessaging stdout

# web-ext run --firefox=nightly --firefox-profile fhill2-nightly

# FOR DEBUGGING in firefox with no web-ext:
# about:debugging -> load temporary addon -> inspect -> console
# in this console view, native messaging host stderr doesnt show, but browser extension stderr does
# to show native messaging stderr -> ctrl+shift+j on console to open browser console
# addon needs to be added if firefox is restarted (unless you use web-ext to launch firefox (modify shortcut)



# NATIVEMESSAGING MANIFEST LOCATIONS
# https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Native_manifests#linux

# permissions for fzf_buku app/manifest.json:
# "permissions": [
   # "nativeMessaging",
   # "tabs",
   # "http://*/*",
   # "https://*/*"
 # ]

import subprocess
subprocess.run("fuser -k -n tcp 10000", capture_output=True, shell=True)
from f.util import log
import socket
import select
import sys
import json
import struct

def json_error(s):
    """returns a json error string to send to a client or browser extension"""
    """only used for when the server needs to send to a connected client that the server received invalid json"""
    return json.dumps({
        "type": "error",
        "message": s
        }).encode("utf-8")

class InputOutput():
    """represents stdin stdout of app as a class so it can be used with select"""
    def __init__(self, readers):
        log("input started to read")

#
        self.readers = readers
        pass
    def fileno(self):
        return sys.stdin.fileno()

    def on_read(self):
        """on stdin - when the browser extension sends a message to the native messaging host"""
        """bytes string -> bytes string"""
        raw_length = sys.stdin.buffer.read(4)
        message_length = struct.unpack('=I', raw_length)[0]
        message = sys.stdin.buffer.read(message_length)
        log("[Server] Received msg from browser extension")
        msg = struct.pack('>I', len(message)) + message
        for reader in self.readers:
            reader.s.sendall(msg)



class Conn():
    """a socket that is talking to a connected client"""
    def __init__(self, conn, ev):
        self.ev = ev
        self.s = conn
    def fileno(self):
        return self.s.fileno()

    def get_response(self):
        data_size = struct.unpack('>I', self.s.recv(4))[0]
        received_payload = b""
        reamining_payload_size = data_size
        while reamining_payload_size != 0:
            received_payload += self.s.recv(reamining_payload_size)
            reamining_payload_size = data_size - len(received_payload)
        return received_payload

    def on_read(self):
        """on_read is byte string -> byte string"""
        try: 
            res = self.get_response()
        except:
            self.close_connection()
        else: 
            log("[Server] Received msg from client")
            if res == "":
                self.close_connection()
            length = struct.pack('@I', len(res))
            sys.stdout.buffer.write(length)
            sys.stdout.buffer.write(res)

    def close_connection(self):
        log("[Server] closing connection to client...")
        if self.s.fileno() != -1:
            self.s.shutdown(2)
            self.ev.readers.remove(self)
        return
    



class Server():
    """the socket that clients can ask to connect to"""
    """opens a new socket to connect to the requesting client"""
    def __init__(self, ev):
        self.ev = ev
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        self.s.bind(('localhost', 10000))
        self.s.listen(10) # max connections
    def fileno(self):
        return self.s.fileno()
    def on_read(self):
        new_conn, addr = self.s.accept()
        log('[Server] Accepting connection from {}'.format(addr))
        self.ev.readers.append(Conn(new_conn, self.ev))
        
    def send(self, msg):
        self.s.send(msg)

class EventLoop():
    def __init__(self):
        self.readers = []
        self.input = InputOutput(self.readers)
        self.server = Server(self)

    def run_forever(self):
        while True:
            # combine all readers into a list
            all_readers = []
            for reader in self.readers:
                all_readers.append(reader)
            all_readers.append(self.server)
            all_readers.append(self.input)
            
            readers, _, _ = select.select(all_readers, [], [])
            for reader in readers:
                reader.on_read() 

log("========== STARTUP ==========")
event_loop = EventLoop()
event_loop.run_forever()


    # def get_message(self):
        # """get msg from stdin - returns byte string"""
        # if not raw_length:
            # log("[Server] sys.exit()!!")
            # sys.exit(0)
               # return message
               # https://github.com/mdn/webextensions-examples/blob/master/native-messaging/app/ping_pong.py
    # 
    # def recvall(self, n):
    #     # Helper function to recv n bytes or return None if EOF is hit
    #     data = bytearray()
    #     while len(data) < n:
    #         packet = self.s.recv(n - len(data))
    #         if not packet:
    #             return None
    #         data.extend(packet)
    #     return data
    #
    # def get_message(self):
    #     # Read message length and unpack it into an integer
    #     raw_msglen = self.recvall(4)
    #     if not raw_msglen:
    #         return None
    #     msglen = struct.unpack('>I', raw_msglen)[0]
    #     return self.recvall(msglen)
    #
    # def get_response(self):
    #     raw_length = self.s.recv(4)
    #     message_length = struct.unpack('=I', raw_length)[0]
    #     data = self.s.recv(message_length).decode("utf-8")
    #     if data == "":
    #         log("no data returned")
    #     return data
    #

    # def try_send_message(self, message):
    #     """even if an empty string is received from clients, the socket still might not be connected or active"""
    #     try:
    #         encodedLength = struct.pack('@I', len(message))
    #         self.s.send(encodedLength)
    #         self.s.send(message)
    #     except:
    #         log("[Server Msg] errored when trying to send: " + message.decode("utf-8"))
    #         self.close_connection()


#
#
# #            # ensure json is valid before sending to browser extension
#             try:
#                 res = json.loads(res)
#             except ValueError as error:
#                 log("[Server msg] invalid json: %s" % error)
#                 # send back to the app that the server received invalid json
#                 self.try_send_message(json_error("invalid json"))
#                 return
#             else:
#                 data = res["data"]
#                 # ensure the message contains a "command" and "message keys"
#                 log(data)
#                 if "command" not in data.keys() or "message" not in data.keys():
#                     self.try_send_message(json_error("data dict needs command and message key"))
#                     return
#                 log("[Server] received from client - type: " + str(data["command"]) + " - message: " + str(data["message"]))
